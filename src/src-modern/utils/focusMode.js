// src/src-modern/utils/focusMode.js
// Utilities to support Node Focus Mode adjacency and visibility calculations.

/**
 * Build an undirected adjacency map of direct node connections based on relationship data.
 * Child relationships connect parents (from the referenced relationship) to the child node.
 * @param {Array} relationships - All relationship records in the canvas state.
 * @returns {Map<string, Set<string>>} Map of nodeId -> Set of directly connected nodeIds.
 */
export const buildFocusGraph = (relationships = []) => {
  const graph = new Map();
  const relationshipLookup = new Map();

  relationships.forEach((rel) => {
    if (!rel || !rel.id) return;
    relationshipLookup.set(rel.id, rel);
  });

  const addConnection = (fromId, toId) => {
    if (!fromId || !toId) return;
    if (fromId === toId) return;

    if (!graph.has(fromId)) {
      graph.set(fromId, new Set());
    }
    if (!graph.has(toId)) {
      graph.set(toId, new Set());
    }

    graph.get(fromId).add(toId);
    graph.get(toId).add(fromId);
  };

  relationships.forEach((rel) => {
    if (!rel) return;

    if (rel.type === 'child') {
      const parentRelationship = relationshipLookup.get(rel.from);
      if (!parentRelationship) return;

      const parents = [parentRelationship.from, parentRelationship.to].filter(Boolean);
      const childId = rel.to;

      parents.forEach((parentId) => addConnection(parentId, childId));
      return;
    }

    addConnection(rel.from, rel.to);
  });

  return graph;
};

/**
 * Get the direct neighbor set for a focused node from the adjacency graph.
 * @param {string|null} focusedNodeId - Node id currently focused.
 * @param {Map<string, Set<string>>} graph - Focus adjacency map.
 * @returns {Set<string>} Set of directly connected node ids.
 */
export const getConnectedNodeIds = (focusedNodeId, graph) => {
  if (!focusedNodeId || !graph) {
    return new Set();
  }

  const neighbors = graph.get(focusedNodeId);
  if (!neighbors) {
    return new Set();
  }

  return new Set(neighbors);
};

/**
 * Build a lookup table for relationships by id.
 * @param {Array} relationships - All relationships.
 * @returns {Map<string, object>} Map of relationship id -> relationship record.
 */
export const createRelationshipLookup = (relationships = []) => {
  const lookup = new Map();
  relationships.forEach((rel) => {
    if (rel && rel.id) {
      lookup.set(rel.id, rel);
    }
  });
  return lookup;
};

/**
 * Get all participant node ids for the provided relationship.
 * For child relationships this includes the child and all parents referenced by the parent relationship.
 * @param {object} relationship - Relationship record.
 * @param {Map<string, object>} relationshipLookup - Lookup of relationships by id.
 * @returns {Set<string>} Set of relevant node ids involved in the relationship.
 */
export const getRelationshipParticipantIds = (relationship, relationshipLookup) => {
  const participants = new Set();
  if (!relationship) {
    return participants;
  }

  if (relationship.type === 'child') {
    if (relationship.to) {
      participants.add(relationship.to);
    }
    const parentRelationship = relationshipLookup.get(relationship.from);
    if (parentRelationship) {
      if (parentRelationship.from) {
        participants.add(parentRelationship.from);
      }
      if (parentRelationship.to) {
        participants.add(parentRelationship.to);
      }
    }
    return participants;
  }

  if (relationship.from) {
    participants.add(relationship.from);
  }
  if (relationship.to) {
    participants.add(relationship.to);
  }
  return participants;
};

/**
 * Determine which relationship ids should be rendered at full opacity given the visible node set.
 * @param {Array} relationships - All relationships.
 * @param {Set<string>} visibleNodeIds - Nodes that should remain fully opaque.
 * @param {Map<string, object>} relationshipLookup - Lookup map generated by createRelationshipLookup.
 * @param {string} [focusedNodeId] - Optional node id that is currently focused.
 * @returns {Set<string>} Relationship ids that should be highlighted.
 */
export const getHighlightedRelationshipIds = (
  relationships,
  visibleNodeIds,
  relationshipLookup,
  focusedNodeId
) => {
  const highlighted = new Set();
  if (!relationships || relationships.length === 0) {
    return highlighted;
  }

  if (!visibleNodeIds) {
    relationships.forEach((rel) => {
      if (rel && rel.id) {
        highlighted.add(rel.id);
      }
    });
    return highlighted;
  }

  relationships.forEach((rel) => {
    if (!rel || !rel.id) return;

    const participants = getRelationshipParticipantIds(rel, relationshipLookup);
    if (focusedNodeId && !participants.has(focusedNodeId)) {
      return;
    }
    const shouldHighlight = Array.from(participants).some((id) => visibleNodeIds.has(id));

    if (shouldHighlight) {
      highlighted.add(rel.id);
    }
  });

  return highlighted;
};